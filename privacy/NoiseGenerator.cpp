//
// Created by Fengmei Jin on 5/7/2022.
//
#include "NoiseGenerator.h"
#include <boost/math/special_functions/lambert_w.hpp> // For lambert_w function.

using boost::math::lambert_wm1;

const int seed_value = 60;

// ======== used when the seed is fixed ("constant" is unexpected)
static int cnt = 0;

int NoiseGenerator::intFromUniformDistribution(int a, int b, bool fixedSeed) {
    if(!fixedSeed) {
        static random_device rd;            // Will be used to obtain a seed for the random number engine
        static mt19937 gen(rd());      // Standard mersenne_twister_engine seeded with rd()

        uniform_int_distribution<int> dis(a, b);    // range: [a,b]
        return dis(gen) % b + a;    // range: [a, b)
    }
    else {
        mt19937 rng(seed_value);        // fix seed generation
        uniform_int_distribution<int> uni_dist(a, b);
        return uni_dist(rng) % b + a;   // range: [a, b)
    }
}

double NoiseGenerator::doubleFromUniformDistribution(double a, double b, bool fixedSeed) {
    if(!fixedSeed) {
        static random_device rd;            // Will be used to obtain a seed for the random number engine
        static mt19937 gen(rd());      // Standard mersenne_twister_engine seeded with rd()
        //        static default_random_engine gen;

        uniform_real_distribution<double> dis(a, b);    // range: [a,b)
        return dis(gen);            // Use dis to transform the random unsigned int generated by gen into a double in [a, b).
                                        // Each call to dis(gen) generates a new random double
    }
    else {
        mt19937 rng(seed_value * (cnt++ % 10));        // fix seed generation
        uniform_real_distribution<double> dis(a, b);
        return dis(rng);
    }
}

//float NoiseGenerator::fromLinearLaplaceDistribution(float epsilon, float sensitivity, float mean) {
//    float lamda = sensitivity / epsilon;        // Lap(mean = 0, lamda = sensitivity/eps) ~ \eps-DP
//
//    // discard: a predictable sequence, not really random
//    //    srand( (unsigned)time( nullptr ) );
//    //    float randomfloat = rand() % RAND_MAX / ((float) RAND_MAX + 1) - 0.5;    // from [0,1) to [-0.5, 0.5)
//
//    double randomV = doubleFromUniformDistribution(0.0, 1.0) - 0.5;
//    double randomV_sng = randomV == 0 ? 0 : (randomV > 0 ? 1 : -1);
//
//    // inverse CDF
//    //      F-1(x) = mean - lamda * sign(random) * ln(1 - 2 * |random|)
//    //      where random ~ UNIFORM (-0.5,0.5)
//    double noise = mean - lamda * randomV_sng * log(1 - 2 * abs(randomV));
//    return (float) noise;
//}

pair<float, float> NoiseGenerator::fromPlanarLaplaceDistribution(float epsilon, bool fixedSeed) {
    double angle = doubleFromUniformDistribution(0, 360, fixedSeed);     //[0, 360)
    double p = doubleFromUniformDistribution(0, 1, fixedSeed);
    double lambertW = lambert_wm1((p - 1) * exp(-1));     // Lambert W function (-1 branch)
    double radius = -1 * (1 / epsilon) * (lambertW + 1);
    return make_pair(angle, radius);
}


vector<Trip*> NoiseGenerator::sampleQuery(int expectedNum, const vector<Trip *> &data, bool fixedSeed){
    vector<Trip*> sampledTrips;
    int total = (int) data.size();
    for(const auto & pair: data) {
        int randomV = intFromUniformDistribution(0, total, fixedSeed);
        if(randomV < expectedNum) {
            sampledTrips.emplace_back(pair);
            expectedNum--;
        }
        if(expectedNum <= 0) {
            break;
        }
        total--;
    }
    return sampledTrips;
}